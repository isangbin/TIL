# 알고리즘 - 배열

## 알고리즘

문제를 해결하기 위한 단계적인 절차나 방법

알고리즘을 표현하는 방법

- 의사코드(슈도코드, Pseudocode)
- 순서도



좋은 알고리즘이란?

- 정확성 : 얼마나 정확하게 동작하는가
- 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
- 단순성 : 얼마나 단순한가
- 최적성 : 더 이상 개선할 여지 없이 최적화되었는가



알고리즘의 성능은 무엇으로 측정하는가

- 시간 복잡도
  - 실제 걸리는 시간을 측정
  - 실행되는 명령문의 개수를 계산
    - 빅-오 표기법
      - 가장 큰 영향을 주는 최고차항의 계수를 제거한 후 표현
      - 연산이 3n^2+2 이면 O(n^2)



## 배열

> 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조



배열의 필요성

- 다량의 변수를 일일이 선언하는 것은 비효율적
- 다수의 변수로 하기 힘든 작업을 한번에 수행 가능



## 정렬

정렬 방식의 종류

- 버블 정렬
- 카운팅 정렬
- 선택 정렬
- 퀵 정렬
- 삽입 정렬
- 병합 정렬



### 버블 정렬

- 첫 원소부터 인접원소끼리 자리를 교환하며 마지막까지 이동
- 한 단계당 한개씩 마지막 자리로 이동
- 시간 복잡도 : O(n^2)

```python
def BubbleSort(a, N):
    for i in range(N-1, 0, -1):
        for j in range(0, i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

- 가장 코딩이 쉽다.



### 카운팅 정렬

- 집합에 각 항목이 몇 개씩 있는지 세어 선형 시간에 정렬하는 효율적  알고리즘
- 정수나 정수로 표현할 수 있는 자료에만 적용 가능
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내 가장 큰 정수를 알아야함
- 시간 복잡도 : O(n + k), n은 리스트 길이, k는 정수의 최대값



방법

- Data에서 각 항목의 발생 횟수 카운트, 정수 항목들로 직접 인덱스 되는 배열에 저장
- counts의 원소를 앞까지의 합으로 조정
- DATA의 맨 끝원소부터 counts를 1 감소시키고 temp에 해당 값 idx에 투입

```python
def Counting_Sort(A, B, k)
# A[] -- 입력배열 (1 to k)
# B[] -- 정렬된 배열
# C[] -- 카운트 배열
	
    C = [0] * (k+1)
    
    for i in range(0, len(A)) :
        C[A[i]] += 1
        
    for i in range(1, len(C)) :
        C[i] += C[i-1]
        
    for i in range(len(B)-1, -1, -1) :
        C[A[i]] -= 1
        B[C[A[i]]] = A[i]
```

- n, k가 비교적 작을 때만 가능하다.



## 완전검색

완전검색 방법

- 해법의 모든 경우의 수를 나열해보고 확인하는 기법
- Brute-force 혹은 generate-and-test 기법이라고도 함
- 모든 방법을 테스트한 후 최종 해법을 도출함
- 일반적으로 경우의 수가 상대적으로 작을 때 유용
- 순열 사용



## 그리디

최적해를 구하는데 사용되는 근사적인 방법

여러 경우중 하나를 결정해야 할 때 마다 그 순간 최적이라고 생각되는걸 선택

단, 매 순간 최적의 선택을 한 것이 최종적으로 그것이 최적이라는 보장은 X



- 해 선택 : 현상태의 최적해를 구해 부분해 집합에 추가
- 실행가능성 검사 : 새로운 부분해 집합이 실행가능한지(문제조건위반안하는지) 확인
- 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지 확인.
- 해 검사에서 전체문제의 해가 아닌것으로 판명되면 1부터 다시 시작.